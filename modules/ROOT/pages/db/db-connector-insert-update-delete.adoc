= Insert, Update, and Delete Data with the Database Connector - Mule 4
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

The Database connector supports insert, update, and delete operations.
Similar to the SELECT operation, these operations support dynamic queries and
parameterization by using embedded DataWeave transformations while also
supporting `fetchSize`, `maxRows`, and timeout parameters. Although examples of input
parameterization, dynamic queries, and parameter usage are provided, you can consult
the xref:db/db-connector-query.adoc[SELECT operation documentation]
for more information.

== Insert Example

Suppose there is a database schema called *Products* that has a table called
*electronic*. *electronic* contains columns called *id*, *name*, *description*, *price*, and *discount*.
The table is created with the following SQL statement:

[source,sql,linenums]
----
CREATE TABLE electronic(
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    description VARCHAR(255),
    price SMALLINT,
    discount TINYINT
)
----

For an example on creating a table using the Database connector, check how to
xref:db/db-connector-ddl.adoc[Execute DDL Statements].

Given that the table is already created and that a there is a
xref:db/db-configure-connection.adoc[connection configuration] named `dbConfig`,
to insert a new record into the *electronic* table, it would be done like this:

[source,xml,linenums]
----
<db:insert config-ref="dbConfig">
  <db:sql>
    INSERT INTO electronic(name, description, price, discount)
    VALUES ('Coffee Machine', 'Model: XYZ99. Uses small size capsules.', 120, 5)
  </db:sql>
</db:insert>
----

Note that the *id* parameter is not passed in the query because it is an
autoincrement key that is generated automatically by the database.

[NOTE]
=============
To benefit from the advantages of
xref:db/db-connector-query.adoc#_use_input_parameters_to_protect_database_queries[input parameters],
the equivalent query should be written as follows:
[source,xml,linenums]
----
<db:insert config-ref="dbConfig">
    <db:sql>
        INSERT INTO electronic(name, description, price, discount)
        VALUES (:name, :description, :price, :discount)
    </db:sql>
    <db:input-parameters>#[{
        name: 'Coffee Machine',
        description: 'Model:XYZ99. Uses small size capsules.',
        price: 120,
        discount: 5}]
    </db:input-parameters>
</db:insert>
----
=============

The `insert` operation will output a `Statement Result` object that contains 2 fields: a _affectedRows_
integer that indicates how many rows were affected by the query, and a _generatedKeys_ map
which contains the autogenerated keys. Given this example, the output is as follows:

[source,json,linenums]
----
{
  "affectedRows": 1,
  "generatedKeys": {

  }
}
----

The _generatedKeys_ map is empty, although a row is successfully added to the table.
This is because this information is disabled by default in order to avoid large overheads.
To activate the information and generate keys, add the `autoGenerateKeys` parameter, and then set it to true:

[source,xml,linenums]
----
<db:insert config-ref="dbConfig" autoGenerateKeys="true">
   <db:sql>
       INSERT INTO electronic(name, description, price, discount)
       VALUES (:name, :description, :price, :discount)
   </db:sql>
   <db:input-parameters>#[{
       name: 'Coffee Machine',
       description: 'Model:XYZ99. Uses small size capsules.',
       price: 120,
       discount: 5}]
   </db:input-parameters>
</db:insert>
----

If the statement generates multiple keys per affected row, you can specify which columns
should be returned by setting the parameter `autoGeneratedKeysColumnNames` to a list that contains
the desired column names. For example, to ensure only the _id_ column is
returned, set the parameter to a DataWeave list with a single string element:
[source,xml,linenums]
----
<db:insert config-ref="dbConfig" autoGenerateKeys="true" autoGeneratedKeysColumnNames="#[['id']]">
    ...
</db:insert>
----

== Update Example

Given the table that is defined in the previous example, the operation to update the *electronic* table
to set the discount to 10 percent for all items that have a price above 100 is as follows:

[literal,source,xml,linenums]
....
<db:update config-ref="dbConfig">
    <db:sql><![CDATA[#["UPDATE electronic SET discount = :discount WHERE price > :price"]]]></db:sql>
	<db:input-parameters>#[{
        discount: 10,
        price: 100
    }]</db:input-parameters>
</db:update>
....

The `<![CDATA[...]]>` wrapper allows of the use of special characters, such as `>` or `"`, in the query.
Otherwise, xml-escaped versions of those characters must be used, such as `+&gt;+` and  `+&quot;+`.

When you use Studio's visual user interface for connectors, instead of the xml code view, special
characters can be directly typed into the `SQL Query Text` box, and Studio will automatically
change the character to its escaped version in the xml view.

== Delete Example

Given the table defined in the <<_insert_example>>, the following operation
 deletes the record with _id_ 1 from the *electronic* table:

[source,xml,linenums]
----
<db:delete config-ref="dbConfig">
    <db:sql>DELETE FROM electronic WHERE id = :id</db:sql>
    <db:input-parameters>#[{
        id: 1
    }]</db:input-parameters>
</db:delete>
----

== See Also

* https://forums.mulesoft.com[MuleSoft Forum]
* https://support.mulesoft.com/s/knowledge[Knowledge Base Articles]
