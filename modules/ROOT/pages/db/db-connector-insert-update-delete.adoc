= Insert, Update, and Delete Data with the Database Connector - Mule 4
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

The Database connector also provides insert, update and delete operations. Just
like the SELECT operation, these operations support dynamic queries and
parameterization by using embedded DataWeave transformations, while also
supporting `fetchSize`, `maxRows` and timeout parameters. Although we will provide
examples of input parameterization, dynamic queries and parameters, we strongly recommend
reading the xref:db/db-connector-query.adoc[SELECT operation documentation]
for a better understanding of these concepts.

== Insert Example

Suppose we have a database schema called *Products* with a table called
*electronic* that has *id, name, description, price* and *discount* columns
and was created with the following SQL statement.

[source,sql,linenums]
----
CREATE TABLE electronic(
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    description VARCHAR(255),
    price SMALLINT,
    discount TINYINT
)
----

If you wish to see an example on creating a table using the
Database Connector, see how to xref:db/db-connector-ddl.adoc[Execute DDL Statements].

Given that the table is already created and that we have
xref:db/db-configure-connection.adoc[configured a connection] named `dbConfig`,
if we wish to insert a new record into our *electronic* table, we would do it like this:

[source,xml,linenums]
----
<db:insert config-ref="dbConfig">
  <db:sql>
    INSERT INTO electronic(name, description, price, discount)
    VALUES ('Coffee Machine', 'Model: XYZ99. Uses small size capsules.', 120, 5)
  </db:sql>
</db:insert>
----

Note that we are not passing the *id* parameter in the query because it is an
autoincrement key generated automatically by the database.

[NOTE]
=============
If we wish to benefit from the advantages of
xref:db/db-connector-query.adoc#_use_input_parameters_to_protect_database_queries[input parameters],
we would write the equivalent query like this:
[source,xml,linenums]
----
<db:insert config-ref="dbConfig">
    <db:sql>
        INSERT INTO electronic(name, description, price, discount)
        VALUES (:name, :description, :price, :discount)
    </db:sql>
	<db:input-parameters>#[{
        name: 'Coffee Machine',
        description: 'Model:XYZ99. Uses small size capsules.',
        price: 120,
        discount: 5}]
	</db:input-parameters>
</db:insert>
----
=============

The `insert` operation will output a `Statement Result` object which contains 2 fields: a _affectedRows_
integer that indicates how many rows were affected by the query, and a _generatedKeys_ map
which contains the autogenerated keys. In our example the output would be:

[source,json,linenums]
----
{
  "affectedRows": 1,
  "generatedKeys": {

  }
}
----

You might wonder why the _generatedKeys_ map is empty although we successfully inserted a
row into the table. To avoid overheads, this data is disabled by default. To activate
it, you must add the `autoGenerateKeys` parameter and set it to true:

[source,xml,linenums]
----
<db:insert config-ref="dbConfig" autoGenerateKeys="true">
    ...
</db:insert>
----

If the statement generates multiple keys per affected row, you can specify which columns you want
returned by setting the parameter `autoGeneratedKeysColumnNames` to a list with the column names.
In our case, we only want the _id_ column returned so we will set the parameter to a list with
a single string element:
[source,xml,linenums]
----
<db:insert config-ref="dbConfig" autoGenerateKeys="true" autoGeneratedKeysColumnNames="#[['id']]">
    ...
</db:insert>
----

== Update Example

Given the table we defined in the previous example, if we want to update the *electronic* table
to give set the discount to 10 percent for all items with a price above 100, we would do it like this:

[source,xml,linenums]
----
<db:update config-ref="dbConfig">
    <db:sql> UPDATE electronic SET discount = :discount WHERE price &gt; :price </db:sql>
	<db:input-parameters >#[{
        discount: 10,
        price: 100
    }]</db:input-parameters>
</db:update>
----

Notice that we must use the xml-escaped version of the `>` sign in our query: `+&gt;+`. If you
wish to be more clear and use the `>` sign then you must turn the query text into a DataWeave
expression like this:

[source,xml,linenums]
----
<db:sql> #["UPDATE electronic SET discount = :discount WHERE price &gt; :price"] </db:sql>
----

If you are using Studio's visual UI for connectors, instead of the xml code view, you can
directly type `>` or any other sign in the `SQL Query Text` box and Studio will automatically
change it to its escaped version in the xml view.

== Delete Example

Given the table defined in the <<_insert_example>>, say we wish to delete the record with
_id_ 1 from the *electronic* table

[source,xml,linenums]
----
<db:delete config-ref="dbConfig">
    <db:sql>DELETE FROM electronic WHERE id = :id</db:sql>
    <db:input-parameters>#[{
        id: 1
    }]</db:input-parameters>
</db:delete>
----

== See Also

* https://forums.mulesoft.com[MuleSoft Forum]
* https://support.mulesoft.com/s/knowledge[Knowledge Base Articles]