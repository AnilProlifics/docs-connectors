= To Publish Messages and Listen for Replies
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: jms, connector, publish, consume, request, reply



Request/Reply is a very common pattern between applications, thus the new JMS
Connector provides an operation specially designed for that, called `publish-consume`.
The `publish-consume` operation allows you to publish a Message to any destination,
and then wait for a reply on a different Destination.

When using this operation, the _JMSReplyTo_ header of the outgoing Message will
contain the id of the Destination on which our application will be waiting for a
response. This destination may be a well-known destination, or it may be a
temporary destination created on the fly with the only purpose of receiving a
single response message.

Finally, the result of the operation will be the Message received as a response,
with exactly the same structure as if a `consume` operation was invoked.

== Waiting For A Reply On A Temporary Queue

Using a temporary Queue to wait for a response is very simple, just configure
the message being sent and the operation will automatically wait for a response
in a temporary Queue:
[source,xml,linenums]
----
<jms:publish-consume config-ref="config" destination="targetDestination" maximumWait="20" maximumWaitUnit="SECONDS"/>
----

In this example, the operation will `publish` a Message with the current
`payload` as its *body* and the *JMSReplyTo header* configured to a temporary
destination, to the `targetDestination`.
Then, it will automatically try to consume the response from that temporary
Queue until a Message is consumed or the `maximumWait` is reached (in which case
  it will fail with a `JMS:TIMEOUT` error).

== Receiving The Reply On A Known Queue

In many cases you don't want reply queues to be created per-request basis, but
instead a well-known Queue is used for replies. For this cases, all you have to
do is to configure the `reply-to` parameter on the outgoing Message:
[source,xml,linenums]
----
<jms:publish-consume config-ref="config" destination="targetDestination">
    <jms:message>
        <jms:reply-to destination="replyToDestination"/>
    </jms:message>
</jms:publish-consume>
----

Now the operation will `publish` a Message to the `targetDestination` with the
current `payload` as its *body* and the `JMSReplyTo` *header* configured with
the `replyToDestination`.
Then, it will automatically try to consume the response from the
`replyToDestination` Queue until a Message is consumed or the `maximumWait` is
reached (in which case it will fail with a `JMS:TIMEOUT` error).

== Request Reply Patterns
*Since JMS Connector 1.6.0*

In JMS exists two well know Request-Reply patterns of how request and reply messages
are correlated, this means how ensure that the incoming message is the proper reply
of the outgoing message.

=== Correlation ID Pattern

This pattern is the default one in the Publish Consume Operation, the usage of
this pattern implies that the operation after publishing a message to the
destination queue, will consume a message using a selector expecting a message
with the same Correlation ID used to publish the request message.

.Client and Listener JMS Correlation ID pattern implementation
[source,xml,linenums]
----
<flow name="publish-consume-correlation-id">
  <jms:publish-consume config-ref="config" destination="targetDestination" requestReplyPattern="CORRELATION_ID">
    <jms:message >
      <jms:reply-to destination="replyToDestination" />
    </jms:message>
  </jms:publish-consume>
  <logger message="Received message from 'replyToDestination' with Correlation ID: #[attributes.headers.correlationId]"/>
</flow>

<flow name="jms-listener-correlation-id" >
  <jms:listener config-ref="config" destination="targetDestination">
    <jms:response requestReplyPattern="CORRELATION_ID" />
  </jms:listener>
  <logger level="INFO" message="About to reply to 'targetDestination' with Correlation ID: #[attributes.headers.correlationId]"/>
</flow>
----

=== Message ID Pattern

At difference with the Correlation ID Pattern, the usage of this pattern implies
that the operation after publishing a message to the destination queue, will
consume a message using a selector expecting a message with the a Correlation ID
with the same value of the Message ID of the request message.


.Client and Listener JMS Message ID pattern implementation
[source,xml,linenums]
----
<flow name="publish-consume-message-id">
  <jms:publish-consume config-ref="config" destination="targetDestination" requestReplyPattern="MESSAGE_ID">
    <jms:message >
      <jms:reply-to destination="replyToDestination" />
    </jms:message>
  </jms:publish-consume>
  <logger message="Received message from 'replyToDestination' with Correlation ID: #[attributes.headers.correlationId]"/>
</flow>

<flow name="jms-listener-message-id" >
  <jms:listener config-ref="config" destination="targetDestination">
    <jms:response requestReplyPattern="MESSAGE_ID" />
  </jms:listener>
  <logger level="INFO" message="About to reply to 'targetDestination' with Correlation ID: #[attributes.headers.messageId]"/>
</flow>
----

=== None

Also the operation can be configured to not use none of above patterns, and the
consumer will try to consume from the reply queue without using any selector
to correlate messages.

This option is useful when working with temporal queues where is ensured that
the queue will have only one message.

== See Also

* xref:jms/jms-publish.adoc[To Publish Messages]
