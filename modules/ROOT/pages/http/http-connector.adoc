= HTTP Connector
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

Release Notes: xref:release-notes::connector/connector-http.adoc[HTTP Connector Release Notes]

The HTTP connector allows declaring HTTP servers that can listen to
requests and trigger flows, as well as HTTP clients that can communicate with any
HTTP service. This means that the HTTP connector effectively allows you to both
expose and consume HTTP based APIs. 

Examples of HTTP based APIs are that the HTTP connector powers both APIkit
and RESTConnect.

The HTTP connector also supports HTTPS (TLS) connectivity, provides easy ways to serve static
resources and secure servers, as well as handling a number of client authentication schemes.

== HTTP Servers

HTTP servers expose services for users or applications to consume. They
receive data in the form of HTTP requests and return a response. For the connector,
this means triggering flows when a request is received and answering back once the
flow finishes. This is all handled by the HTTP Listener, a source the connector provides.

=== Set Up an HTTP Server

Declare an HTTP server by first defining an HTTP Listener connection, which defines the
host and port where HTTP requests are received.

For example:

[source,xml,linenums]
----
<http:listener-config name="serverConfig">
  <http:listener-connection host="localhost" port="8081"/>
</http:listener-config>
----

In this example, the HTTP Listener is named `serverConfig` and listens on a computer's localhost address
(IP address 127.0.0.1) and on port 8081. After you set up a server in Anypoint Studio or Design Center, 
you can access this listener at the `+http://localhost:8081+` URL and the server responds depending on 
how you configure the application.

You can choose specific resource paths to execute a flow, so that when a request
is received matching that path, Mule runs your flow.

The following example displays either Hello World or Goodbye World depending on how you configure the HTTP connector:

[source,xml,linenums]
----
<flow name="hello">
    <http:listener path="greet" config-ref="serverConfig"/>
    <set-payload value="Hello World!"/>
</flow>

<flow name="bye">
    <http:listener path="exit" config-ref="serverConfig"/>
    <set-payload value="Goodbye World!"/>
</flow>
----

In these examples, an HTTP server is set up to use the previous configuration `serverConfig` that set up
an HTTP Listener on the localhost and port `8081`. Configuring the Hello and Goodbye statements to build
on the previous Listener, the `greet` and `exit` paths execute different flows. 

Thus calling `+http://localhost:8081/greet+` returns `Hello, world!` while calling `+http://localhost:8081/excuse+` 
returns `Goodbye, world!`.

The received HTTP request data is shared with the flow when executed and the responses
can be customized.

In this next example, we add an HTTP body to the application containing the HTTP connector:

[source,xml,linenums]
----
<flow name="hello">
  <http:listener path="greet" config-ref="serverConfig">
    <http:response>
      <http:body>
        #[payload ++ ' I am an HTTP server.']
      </http:body>
    </http:response>
  </http:listener>
  <set-payload value="#['Hello, ' ++ (attributes.queryParams.name default 'world') ++ '!']" />
</flow>
----

Considering the example above, now calling `+http://localhost:8081/greet?name=Ana+`
returns `Hello, Ana! I am an HTTP server.` while calling `+http://localhost:8081/greet+`
returns `Hello, world! I am an HTTP server.`.

You can find a complete overview of the HTTP listener features in the xref:http/http-listener-ref.adoc[HTTP Request Configuration Reference].

== Consume a Service With a Client

HTTP clients allow sending request to HTTP services and handling their response. For
the connector, this means executing a request and returning the answer. This is
handled by an HTTP request, an operation that the connector provides.

HTTP clients don't necessarily need to be declared, though this is recommended to
reuse configurations. If you don't declare an HTTP client, you need to specify the entire
URL each time you want to send a request. Although this
is useful for quick requests, if you do several requests on different
API resources, it is best to declare the client specifying the host to connect to.

[source,xml,linenums]
----
<http:request-config name="clientConfig">
  <http:request-connection host="localhost" port="8081"/>
</http:request-config>
----

Then, each request you provide only needs to feature the path where it should go.

[source,xml,linenums]
----
<flow name="helloAndBye">
  <http:request method="GET" path="greet" config-ref="clientConfig"/>
  <logger level="INFO" message="#[payload]"/>
  <http:request method="GET" path="excuse" config-ref="clientConfig"/>
  <logger level="INFO" message="#[payload]"/>
</flow>
----

In the previous examples we consume the service we exposed before. When our flow
executes, it displays:

[source,xml,linenums]
----
Hello, world! I am an HTTP server.
Goodbye, world!
----

The response data is shared with the flow and the request can be customized.

[source,xml,linenums]
----
<flow name="helloAndBye">
  <http:request method="GET" path="greet" config-ref="clientConfig">
    <http:query-params>
      #[{"name" : "HTTP client"}]
    </http:query-params>
  </http:request>
  <logger level="INFO" 
   message="#['Received a ' ++ attributes.status code ++ ' response with body: {' ++ payload ++ '}']"/>
</flow>
----

When this flow executes, it displays:

[source,xml]
----
Received a 200 response with body: {Hello, HTTP client! I am an HTTP server.}
----

You can find a complete overview of the HTTP request features in the xref:http/http-request-ref.adoc[HTTP Request Configuration Reference].
