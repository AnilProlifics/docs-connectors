= Destination Subscriber
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

The Subscriber source in the Anypoint MQ connector provides the ability to listen for new messages and consume them as they arrive to the destination. You can configure different listening strategies that allow to tune the consumption for performance, predictability, schedules and so on.


== Continuous Listening For New Messages

By default, the Anypoint MQ subscriber will work in a continuous listening mode, providing the maximum throughput by consuming messages as soon as they arrive to the queue. This is called the `prefetch` `subscriber-type` configuration. When using the `prefetch` mode, the subscriber will eagerly attempt to keep a local buffer of messages full at all time, making them readily available to be dispatched to the Mule flow as soon as the application is able to accept it.

In this subscriber type, you'll only configure how large the local buffer can be when full using the `maxBufferSize` parameter. This buffer size will be the ideal target that the subscriber will try to fill up, effectively controlling how eagerly the messages will be taken from the queue.

image:amq-3x-subscriber-prefetch.png[Anypoint MQ Subscriber With Prefetch]

[source,console,linenums]
----
<anypoint-mq:subscriber doc:name="Subscriber" doc:id="36e89876-4b60-4574-a17b-59c6c9f6ad5a" config-ref="Anypoint_MQ_Config" destination="myQueue">
	<anypoint-mq:subscriber-type>
		<anypoint-mq:prefetch maxBufferSize="30"/>
	</anypoint-mq:subscriber-type>
</anypoint-mq:subscriber>
----

IMPORTANT: When a message is taken from the queue and stored in the local buffer, it will effectively appear as in-flight for any other consumer, not allowing them to consume it, remaining in this in-flight state for as long as necessary for the application to begin the processing.

TIP: For maximum performance use a larger buffer size, keeping in mind that the messages kept locally won't be available for any other consumer. Reduce the buffer size if looking for immediate processing of the messages as soon as they are published to the queue while but have a more restricted application level throughput, thus avoiding competing consumers starvation.

When using the `prefetch` mode, the `Acknwoledgement Timeout` timer will begin from the moment the message is dispatched to the flow, and not from when it is taken from the queue. The time the message remains in the local buffer won't count as part of the timeout.


== Polling for New Messages

If instead of maximum throughput, your application requires a more predictable and controlled consumption of the messages, 
you then can configure the Anypoint MQ Subscribers as a polling source, checking for new messages in the queue at a fixed scheduling rate. Every time the poll is triggered, the subscriber will retrieve up to 10 messages to be dispatched to the flow in order one by one. To do so, select the `polling` `subscriber-type`.

Most basic subscriber declaration will look like this:

image:amq-3x-subscriber-default.png[Anypoint MQ Default Subscriber]

[source,console,linenums]
----
<anypoint-mq:subscriber destination="myQueue" config-ref="Anypoint_MQ_Config"/>
----

This subscriber declaration will attempt to retrieve 10 messages from the declared destination every 1 second, dispatching each of the retrieved messages to the flow one by one as a `MuleMessage`.

The resulting Mule message has:

* The message's body as its payload.
* The message's metadata in the message attributes.

image:amq-3x-subscriber-output.png[Anypoint MQ Subscriber Output Message]

INFORMATION: Customizations of the subscriber polling strategy can be done based on the standard Mule Runtime's scheduling strategies: 

    * https://docs.mulesoft.com/mule-runtime/4.1/scheduler-concept#fixed-frequency[Fixed Frequency Strategy]
    * https://docs.mulesoft.com/mule-runtime/4.1/scheduler-concept#cron-expressions[Cron Expressions Strategy]


TIP: Use the `polling` subscriber configuration when in need of a predictable and controlled consumption of the messages from a queue. In exchange for this control, messages that arrive between two polls will not be consumed immediately, but instead will remain in the queue until the next poll of the subscriber is triggered, with a limit of up to 10 messages to be retrieved. This means that if your queue has 15 messages, the first 10 will be consumed by one poll, and the remaining 5 will wait for the next poll.

=== Customized Fixed Polling

The frequency at which the subscriber polls for new messages can be customized by declaring a `anypoint-mq:polling` `anypoint-mq:subscriber-type` strategy with a customized `fixed-frequency` scheduling strategy:

image:amq-3x-subscriber-fixed-frequency.png[Anypoint MQ Subscriber With Custom Fixed Frequency]


[source,console,linenums]
----
<anypoint-mq:subscriber destination="myQueue" config-ref="Anypoint_MQ_Config">
    <anypoint-mq:subscriber-type>
        <anypoint-mq:polling>
            <scheduling-strategy>
                <fixed-frequency frequency="2000" startDelay="100"/>
            </scheduling-strategy>
        </anypoint-mq:polling>
    </anypoint-mq:subscriber-type>
</anypoint-mq:subscriber>
----


=== Cron Based Polling

The Anypoint MQ Subscriber can also leverage a `cron` scheduling strategy, allowing you to schedule jobs such as "Run every minute starting at 2pm and ending at 2:59pm, every day". In order to do so, declare an `anypoint-mq:polling` `anypoint-mq:subscriber-type` strategy with a customized `cron` scheduling strategy:

image:amq-3x-subscriber-cron.png[Anypoint MQ Subscriber With Custom Cron Strategy]


[source,console,linenums]
----
<anypoint-mq:subscriber destination="myQueue" config-ref="Anypoint_MQ_Config">
    <anypoint-mq:subscriber-type>
        <anypoint-mq:polling>
            <scheduling-strategy>
                <cron expression="0 * 14 * * ?" timeZone="America/Los_Angeles"/>
            </scheduling-strategy>
        </anypoint-mq:polling>
    </anypoint-mq:subscriber-type>
</anypoint-mq:subscriber>
----


== Message Acknowledgment

=== Automatic Acknowledgement

By default, the subscriber component will use the `AUTO` `acknowledgementMode`. In this mode, the messages retrieved by the subscriber will be acknowledged automatically once the flow processing of the message results in a success. This means that the subscriber will receive a message, dispatch it to the flow and wait to see how the processing of the message is completed, only executing an ACK when the processing is completed without exceptions.

In case that the execution of the processing flow is completed with a propagated exception, then the message will be automatically NACKed, effectively returning it to the queue for redelivery.

As part of the `AUTO` acknowledgement configuration, is important to consider the `acknowledgementTimeout` parameter, meant to control for how long is the message allowed to remain in-flight waiting to be acknowledged, before automatically returning to the queue. By default, the connector will honor the time defined at queue level from the admin console with the `Message Lock Default TTL` value.

WARNING: The `Acknowledgement Timeout` configuration should provide enough time for the flow to _complete_ the processing of the message, otherwise the acknowledgement will fail with an expired token and a redelivery of the processed message will occurs. Always use an `Acknowledgement Timeout` that better suits your expected application time processing, leaving room for unexpected but possible extra delays due to external systems delay, application back-pressure due to high load, so on. For example, if the consumed message is expected to be processed within 10 seconds, the `acknowledgementTimeout` is recommended to be a minimum of 15 seconds.

=== Immediate Acknowledgement

When the `acknowledgementMode` used is `IMMEDIATE`, the consumed message will be acknowledged right before being dispatched to the Mule flow. If for some reason the acknowledgement of the message fails, then the message will be discarded, that is, won't be dispatched to the flow and will remain in-flight until the acknowledgement timeout eviction.

=== Manual Acknowledgement

If you want to manually control the acknowledgement of the message, then change the `acknowledgementMode` to `MANUAL`. When using the `MANUAL` acknowledgement mode, the application logic decides if and when to perform the acknowledgement of the message, using the xref:anypoint-mq-ack.adoc[ACK] or xref:anypoint-mq-ack.adoc[NACK] operations. 
In order to perform the manual acknowledgement, save the value of the `ackToken` provided as part of the resulting message attributes.

As part of the manual acknowledgement configuration, is important to consider the `acknowledgementTimeout` parameter, meant to control for how long is the message allowed to remain in-flight waiting to be acknowledged, before automatically returning to the queue. 
By default, the connector will honor the time defined at queue level from the admin console with the `Message Lock Default TTL` value.

WARNING: Always use an `Acknowledgement Timeout` that better suits your expected application time processing, leaving room for unexpected but possible extra delays due to external systems delay, application back-pressure due to high load, so on. For example, if the consumed message is expected to be processed within 10 seconds, the `acknowledgementTimeout` is recommended to be a minimum of 15 seconds.


== Circuit Breaker Capability

The Anypoint MQ Connector Subscriber provides out of the box a circuit breaking capability, allowing you to have more control on how the connector deals with errors occurred while processing a consumed message.

=== Circuit Breaker

In any scenario in which you need to connect to a service, consider what happens when an external service fails. A common pattern to deal with downtime of an external service is the Circuit Breaker, which allows the system to stop making requests that are doomed to fail, and also allowing the external service to recover under a reduced load.
The Circuit Breaker goes through three different states (Closed, Open, Half Open), changing the behavior of the application based on the current state. See the https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker[Microsoft Circuit Breaker Pattern] site for more information.

In a Mule 4 application using Anypoint MQ means having a Mule flow with an MQ subscriber that consumes messages from a queue, and processes it using an external service. When this service is not available and the request fails, an error  propagates and processing of the message completes as a failure or as a custom error for handling the message, such as sending it to a DLQ.
When the external service is not available, every attempt to process a message results in a failure, forcing the application to loop on consuming messages that cannot succeed. This can be avoided if the subscriber is notified of the error in a way that prevents it from consuming more messages for a certain period.

=== Circuit Breaker Processes

The circuit breaker capability provided by the `anypoint-mq:subscriber` is bound to the error handling mechanism that Mule provides out of the box, using the errors notification mechanism to keep a count of errors related to an external service, which is known as circuit failures. You can bind any error to a circuit failure, for example you can bind `HTTP:TIMEOUT`, `FTP:SERVICE_NOT_AVAILABLE`, or even a custom error from your application like `ORG:EXTERNAL_ERROR`.

If a Mule flow completes its execution with an error, the subscriber checks if the error is one of the `onErrorTypes` that indicate an external service error, and counts consecutive occurrences until the `errorsThreshold` is reached. When the `errorsThreshold` is reached, the circuit trips and stops polling for new messages for a configurable `tripTimeout` duration. Messages are consumed again on the next poll after the tripTimeout elapses.
By default, the circuit breaking feature is disabled.

=== Circuit Breaker States

image::amq-3x-subscriber-states-view.png[Circuit Breaker States Diagram]

* Closed
+
The starting state where the subscriber retrieves messages normally from MQ based on its configuration, effectively working as if the Circuit Breaker is not present.
+
* Closed-Open Transition
+
When the amount of failures occurs one after the other during message processing, without any success in between the failures and reaches the `errorsThreshold` value, then the circuit breaker trips and transition changes to an open state.
+
Messages that were already dispatched to the flow then complete processing, regardless if the result is success or failure.
+
Messages kept locally which are in-flight for the broker but haven't been dispatched yet, are NACKed and returned to the queue for redelivery to another consumer.
+
* Open
+
The subscriber doesn't attempt to retrieve messages, and skips the iterations silently until the `tripTimeout` is reached.
+
* Half Open
+
After the `tripTimeout` elapses, the subscriber goes to a Half Open state meaning that in the next poll for messages, it retrieves a single message from the service and uses that message to check if the system has recovered before going back to the normal Closed state.
+
When a single message is successfully fetched, dispatched to the flow, and its processing completes with a success, then the subscriber goes back to normal and immediately attempts to fetch more messages.
+
If Mule flow processing fails with one of the expected `onErrorTypes`, the circuit goes back to an Open state and resets the `tripTimeout` timer.

=== Configure the Circuit Breaker

You can configure a Circuit Breaker in two different ways, as a Global Circuit Breaker or as a Private Circuit Breaker. 

In both ways of declaring it, the parameters that can be configured are the same: 

* onErrorTypes - The error types whose occurrence during the flow execution counts as a failure in the circuit. An error occurrence counts only when the flow is completed with an error propagation. By default all errors count as a circuit failure.

* errorsThreshold - The number of `onErrorTypes` errors have to occur for the circuit breaker to open.

* tripTimeout - How long the circuit remains open once the `errorsThreshold` is reached.

* circuitName - The name of a circuit breaker to bind to this configuration. By default each queue has its own circuit breaker.


==== Global Circuit Breaker

Use this when you want to share the circuit state across multiple subscribers, as if all were part of the same "circuit".

In Anypoint Studio go to Global Elements tab in the canvas > Create > Component Configuration > Circuit Breaker. 

image::amq-3x-cb-global-canvas.png[]

Inside this configuration wizard, populate the following fields as needed. Once this configuration is completed, you'll be able to reference this Circuit declaration from any Anypoint MQ Subscriber. To do so, go to the `subscriber` element, click into the Advanced tab, and the choose Circuit Breaker > Global Reference, choosing one from all the circuits available.

image::amq-3x-cb-global-ref.png[]


==== Private Circuit Breaker

Declared internally on a single subscriber, this "circuit" declaration will only be used the flow on which the subscriber is declared, *isolated from all the other circuits*.

To use this configuration, select the `subscriber` component > Advanced Tab > Circuit Breaker > Edit Inline. Here, you'll be able to populate all the fields as needed. 

image::amq-3x-cb-inline.png[]

=== Examples

==== Circuit Configuration for a Single Subscriber

In an example scenario where there's a single `anypoint-mq:subscriber` consuming messages from a queue and posting the messages to another service using its REST API, you can stop processing messages after 5 requests to the external service result in a timeout. Once that happens, the example waits for 30 seconds for the service to recover before retrying with a new message.

For this one config is needed with these circuit breaker parameters:

[source,console,linenums]
----

<anypoint-mq:config name="Anypoint_MQ_Config">
    <anypoint-mq:connection url="${providerUrl}" clientId="${clientId}" clientSecret="${clientSecret}"/>
</anypoint-mq:config>

<flow name="subscribe">
   <anypoint-mq:subscriber config-ref="Anypoint_MQ_Config" destination="${subscribedQueue}">
        <anypoint-mq:circuit-breaker
                        onErrorTypes="HTTP:TIMEOUT" // <1>
                        errorsThreshold="5" // <2>
                        tripTimeout="30" // <3>
                        tripTimeoutUnit="SECONDS"/>
   </anypoint-mq:subscriber>
    <http:request config-ref="RequesterConfig" path="/external" method="POST"/> // <4>
</flow>
----

<1> Configure the error types to trip the circuit. When an error occurs for an `errorsThreshold` amount of times, polling stops.
<2> Set the threshold for how many consequent messages have to occur to consider that the circuit is in a failure state.
<3> After the circuit breaker trips because the `errorsThreshold` is reached, configure how long to wait before you resume polling new messages.
<4> Define the operation to throw the error expected by the `onErrorTypes` parameters.

It's important to notice that any other error not listed in the `onErrorTypes` parameter is ignored by the circuit breaker. For this example, errors like `HTTP:BAD_REQUEST`are ignored.


====  Share a Circuit From Different Queues

In many cases there's a single common service between the processing of messages from different queues. This example configures the `circuitName` parameter to bind both subscribers to a single circuit:

[source,console,linenums]
----

<anypoint-mq:config name="Anypoint_MQ_Config">
    <anypoint-mq:connection url="${providerUrl}" clientId="${clientId}" clientSecret="${clientSecret}"/>
</anypoint-mq:config>

<anypoint-mq:circuit-breaker
           name="InvoiceProcess" // <1>
           onErrorTypes="FTP:RETRY_EXHAUSTED, HTTP:SERVICE_UNAVAILABLE" // <2>
           errorsThreshold="10"
           tripTimeout="5"
           tripTimeoutUnit="MINUTES"/>

<flow name="subscribe">
    <anypoint-mq:subscriber destination="${reservationsQueue}" config-ref="Anypoint_MQ_Config"
                            circuitBreaker="GlobalCircuit"/> // <3>
    <flow-ref name="invoiceProcess">
</flow>

<flow name="otherSubscribe">
    <anypoint-mq:subscriber destination="${paymentsQueue}" config-ref="Anypoint_MQ_Config"
                            circuitBreaker="GlobalCircuit"/> // <3>
    <flow-ref name="invoiceProcess">
</flow>

<sub-flow name="invoiceProcess">
  <ftp:write path="${auditFolder}" config-ref="ftp-config"/> // <4>
  <http:request config-ref="requestConfig" path="/external"/> // <5>
</sub-flow>

----

<1> Set the `name` parameter to share a common circuit breaker on multiple queues.
<2> Consider the two different errors that can affect the processing of messages from the subscriber, passing each as a CSV list.
<3> For both subscribers, reference the global circuit breaker configuration.
<4> This component may throw an `FTP:RETRY_EXHAUSTED` error along with many others. Only the `FTP:RETRY_EXHAUSTED` error is taken into account by the circuit breaker.
<5> The HTTP connector may throw an `HTTP:SERVICE_UNAVAILABLE` preventing the message to be processed.

For this scenario, both subscribers stop polling for messages as soon as the error count reaches the `errorsThreshold="10"` value, counting both `FTP:RETRY_EXHAUSTED` and `HTTP:SERVICE_UNAVAILABLE` errors. When the `tripTimeout` elapses, one of the subscribers polls for a message and uses it to test the circuit, enabling the polling for both subscribers if the processing of that message succeeds.

== See Also

* xref:anypoint-mq/anypoint-mq-consume.adoc[Consume Messages]
* xref:anypoint-mq/anypoint-mq-ack.adoc[Use Topic Subscriptions]
