= Anypoint MQ Subscriber Operation â€” Mule 4
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

The Subscriber operation in the Anypoint MQ connector provides the ability to listen for new messages and consume them as they arrive at the destination. You can configure different listening strategies that enable you to tune the consumption for performance, predictability, and schedules.


== Continuous Listening for New Messages

By default, the Anypoint MQ subscriber works in a continuous listening mode, providing the maximum throughput by consuming messages as soon as they arrive in the queue. This is called the `prefetch` `subscriber-type` configuration. When using the `prefetch` mode, the subscriber attempts to keep a local buffer of messages full, making them available to be dispatched to the Mule flow as soon as the app can accept it.

For this `subscriber-type`, you configure the `maxBufferSize` parameter to specify the maximum size of the local buffer when full. This buffer size is the ideal target that the subscriber tries to fill up, effectively controlling how quickly messages are taken from the queue.

image::anypoint-mq/3.x/amq-3x-subscriber-prefetch.png[Anypoint MQ Subscriber With Prefetch]

[source,xml,linenums]
----
<anypoint-mq:subscriber doc:name="Subscriber"
     doc:id="36e89876-4b60-4574-a17b-59c6c9f6ad5a"
     config-ref="Anypoint_MQ_Config" destination="myQueue">
  <anypoint-mq:subscriber-type>
      <anypoint-mq:prefetch maxBufferSize="30"/>
  </anypoint-mq:subscriber-type>
</anypoint-mq:subscriber>
----

IMPORTANT: When a consumer takes a message from the queue and stores it in the local buffer, the message appears as in-flight for any other consumer and prevents them from consuming it. The message remains in this in-flight state for as long as necessary for the app to begin the processing.

When configuring the buffer size:

* Use a larger buffer size for maximum performance, keeping in mind that the messages kept locally won't be available for any other consumer.
* Use a smaller buffer size to process messages as they are published to the queue.
+
The smaller buffer restricts app-level throughput and avoids blocking competing consumers.

When using the `prefetch` mode, the `acknowledgementTimeout` timer begins from the moment the message is dispatched to the flow - not when it is taken from the queue. The time the message remains in the local buffer doesn't count as part of the timeout.


== Poll for New Messages

If your app requires more predictable and controlled message consumption, rather than maximum throughput, you can configure the `Subscriber` as a polling source. The subscriber checks for new messages in the queue at a fixed scheduling rate. Every time the poll is triggered, the subscriber retrieves up to 10 messages to be dispatched to the flow in order one by one. To do so, select the `polling` `subscriber-type`.

Messages that arrive between two polls aren't consumed immediately. Instead, they remain in the queue until the next poll of the subscriber is triggered. The queue contains up to 10 messages to be retrieved. For example, if your queue has 15 messages, one poll consumes the first 10 messages and the remaining 5 messages wait for the next poll.

// *IS THIS SCREENSHOT CORRECT?*

The most basic subscriber declaration looks like this:

image::anypoint-mq/3.x/amq-3x-subscriber-default.png[Anypoint MQ Default Subscriber]

[source,xml,linenums]
----
<anypoint-mq:subscriber destination="myQueue" config-ref="Anypoint_MQ_Config"/>
----

This subscriber declaration attempts to retrieve 10 messages from the declared destination every 1 second, dispatching each of the retrieved messages to the flow one by one as a `MuleMessage`.

The resulting `MuleMessage` has:

* The message's body as its payload.
* The message's metadata in the message attributes.

image::anypoint-mq/3.x/amq-3x-subscriber-output.png[Anypoint MQ Subscriber Output Message]

You can customize the subscriber polling strategy using the standard Mule Runtime scheduling strategies:

* https://docs.mulesoft.com/mule-runtime/4.1/scheduler-concept#fixed-frequency[Fixed Frequency]
* https://docs.mulesoft.com/mule-runtime/4.1/scheduler-concept#cron-expressions[Cron Expressions]


=== Customized Fixed Polling

You can customize the frequency at which the subscriber polls for new messages by declaring an `anypoint-mq:polling` `anypoint-mq:subscriber-type` strategy with a customized `fixed-frequency` scheduling strategy:

image::anypoint-mq/3.x/amq-3x-subscriber-fixed-frequency.png[Anypoint MQ Subscriber With Custom Fixed Frequency]


[source,xml,linenums]
----
<anypoint-mq:subscriber destination="myQueue"
   config-ref="Anypoint_MQ_Config">
    <anypoint-mq:subscriber-type>
        <anypoint-mq:polling>
            <scheduling-strategy>
                <fixed-frequency frequency="2000"
                 startDelay="100"/>
            </scheduling-strategy>
        </anypoint-mq:polling>
    </anypoint-mq:subscriber-type>
</anypoint-mq:subscriber>
----

=== Cron-Based Polling

The Anypoint MQ Subscriber can also use a `cron` scheduling strategy, which enables you to schedule jobs such as "Run every minute starting at 2pm and ending at 2:59pm, every day". To use this scheduling strategy, declare an `anypoint-mq:polling` `anypoint-mq:subscriber-type` strategy with a customized `cron` scheduling strategy:

image::anypoint-mq/3.x/amq-3x-subscriber-cron.png[Anypoint MQ Subscriber With Custom Cron Strategy]


[source,xml,linenums]
----
<anypoint-mq:subscriber destination="myQueue"
    config-ref="Anypoint_MQ_Config">
    <anypoint-mq:subscriber-type>
        <anypoint-mq:polling>
            <scheduling-strategy>
                <cron expression="0 * 14 * * ?"
                timeZone="America/Los_Angeles"/>
            </scheduling-strategy>
        </anypoint-mq:polling>
    </anypoint-mq:subscriber-type>
</anypoint-mq:subscriber>
----


== Message Acknowledgment

* *Automatic*
+
By default, the Subscriber operation uses the `AUTO` `acknowledgementMode`. In this mode, the messages that the subscriber retrieves are acknowledged automatically once the flow processing of the message succeeds. This means that the subscriber receives a message, dispatches it to the flow, and waits to see how the message processing finishes. It executes an ACK only when the processing finishes without exceptions.
+
If the execution of the processing flow finishes with a propagated exception, the message is automatically not acknowledged, returning it to the queue for redelivery.
+
For more information, see xref:anypoint-mq/3.x/anypoint-mq-ack.adoc#automatic-acknowledgment[Automatic Acknowledgment].

* *Immediate*
+
When you use the `IMMEDIATE` `acknowledgementMode`, the consumed message is acknowledged right before being dispatched to the Mule flow. If the message acknowledgment fails, the message is discarded. The message isn't dispatched to the flow and remains in-flight until the acknowledgment timeout eviction.
+
For more information, see xref:anypoint-mq/3.x/anypoint-mq-ack.adoc#immediate-acknowledgment[Manual Acknowledgment].

* *Manual*
+
To manually control the acknowledgment of the message, change the `acknowledgementMode` to `MANUAL`. When using the `MANUAL` acknowledgment mode, the app logic decides when to perform the acknowledgment of the message, using the xref:anypoint-mq/3.x/anypoint-mq-ack.adoc[ACK] or xref:anypoint-mq/3.x/anypoint-mq-ack.adoc[NACK] operations.
+
To perform the manual acknowledgment, save the value of the `ackToken` provided as part of the resulting message attributes.
+
For more information, see xref:anypoint-mq/3.x/anypoint-mq-ack.adoc#manual-acknowledgment[Manual Acknowledgment].

For information on acknowledgment timeouts, see xref:anypoint-mq/3.x/anypoint-mq-ack.adoc#acknowledgment-timeout[Acknowledgment Timeout].

== Circuit Breaker Capability

The Subscriber operation provides circuit breaking capability, which enables you to control how the connector handles errors that occur while processing a consumed message.

For example, when connecting to an external service, you can use the circuit breaker to handle any downtime of that service. The circuit breaker allows the system to stop making requests and allows the external service to recover under a reduced load.

Using Anypoint MQ in a Mule 4 app means having a Mule flow with an MQ subscriber that consumes messages from a queue and processes them using an external service. When this service isn't available:

. The request fails.
. An error propagates.
. Message processing finishes as either a failure or as a custom error for handling the message, such as sending it to a DLQ.

When the external service is not available, every attempt to process a message results in a failure, forcing the app to loop, consuming messages that cannot succeed. You can avoid this behavior by notifying the subscriber of the error in a way that prevents it from consuming more messages for a certain period.

=== Circuit Breaker Processes

The circuit breaker capability that Subscriber operation provides is bound to the error handling mechanism provided by Mule. It uses the error notification mechanism to keep a count of errors related to an external service, which is known as circuit failures. You can bind any error to a circuit failure, for example you can bind `HTTP:TIMEOUT`, `FTP:SERVICE_NOT_AVAILABLE`, or even a custom error from your app, such as `ORG:EXTERNAL_ERROR`.

If a Mule flow finishes its execution with an error, the subscriber checks if the error is one of the `onErrorTypes` that indicates an external service error, and counts consecutive occurrences until the `errorsThreshold` is reached. When the `errorsThreshold` is reached, the circuit trips and stops polling for new messages the duration specified by `tripTimeout`. Messages are consumed again on the next poll after the tripTimeout elapses.

By default, the circuit breaking feature is disabled.

=== Circuit Breaker States

The circuit breaker has three states: Closed, Open, and Half Open. The behavior of the app changes based on the current state. See the https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker[Microsoft Circuit Breaker pattern] for more information.

image::anypoint-mq/3.x/amq-3x-subscriber-states-view.png[Circuit Breaker States Diagram]

* *Closed*
+
The starting state where the subscriber retrieves messages normally from MQ based on its configuration, effectively working as if the circuit breaker is not present.
+
* *Closed-Open Transition*
+
When the number of failures occurs in succession during message processing, without successes, and reaches the `errorsThreshold` value, the circuit breaker trips and the circuit breaker transitions to an Open state.
+
Messages that were already dispatched to the flow then finish processing, regardless of whether the result is success or failure.
+
Messages kept locally that are in-flight for the broker but haven't been dispatched yet are not acknowledged and returned to the queue for redelivery to another consumer.
+
* *Open*
+
The subscriber doesn't attempt to retrieve messages, and skips the iterations silently until the `tripTimeout` is reached.
+
* *Half Open*
+
After the `tripTimeout` elapses, the subscriber goes to a Half Open state. In the next poll for messages, the subscriber retrieves a single message from the service and uses that message to check if the system has recovered before going back to the normal Closed state.
+
When the subscriber successfully fetches a single message, dispatches it to the flow, and processing finishes successfully, the subscriber returns to normal and immediately attempts to fetch more messages.
+
If Mule flow processing fails with one of the expected `onErrorTypes`, the circuit goes back to an Open state and resets the `tripTimeout` timer.

=== Configure the Circuit Breaker

You can configure a Circuit Breaker as either a Global Circuit Breaker or a Private Circuit Breaker.

Either way, the configuration parameters are the same:

* `onErrorTypes`
+
The error types that count as a failure during the flow execution. An error occurrence counts only when the flow finishes with an error propagation. By default, all errors count as a circuit failure.
* `errorsThreshold`
+
The number of `onErrorTypes` errors that must occur for the circuit breaker to open.
* `tripTimeout`
+
How long the circuit remains open once the `errorsThreshold` is reached.
* `circuitName`
+
The name of a circuit breaker to bind to this configuration. By default, each queue has its own circuit breaker.


==== Global Circuit Breaker

Use a Global Circuit Breaker when you want to share the circuit state across multiple subscribers, as if subscribers are part of the same "circuit".

. In Anypoint Studio, click the *Global Elements* tab in the canvas.
. Select *Create > Component Configuration > Circuit Breaker*.

image::anypoint-mq/3.x/amq-3x-cb-global-canvas.png[]

In the configuration wizard, populate the following fields as needed. Once the configuration is complete, you can reference this `Circuit_breaker` declaration from any Anypoint MQ Subscriber.

To reference a circuit breaker:

. Select the `subscriber` element in the canvas.
. Click the *Advanced* tab.
. Select *Circuit Breaker > Global Reference*, and then choose one from the list.

image::anypoint-mq/3.x/amq-3x-cb-global-ref.png[]


==== Private Circuit Breaker

You declare a Private Circuit Breaker internally on a single subscriber. This circuit declaration is  used only in the flow where the subscriber is declared, isolated from all the other circuits.

To use this configuration:

. Select the Subscriber in the canvas.
. Click the *Advanced* tab.
. Select *Circuit breaker > Edit Inline*, and then choose one from the list.

image::anypoint-mq/3.x/amq-3x-cb-inline.png[]

=== Circuit Breaker Examples

==== Circuit Configuration for a Single Subscriber

In this example, a single subscriber consumes messages from a queue and posts the messages to another service using its REST API. You can stop processing messages after 5 requests to the external service result in a timeout. Once processing stops, the subscriber waits for 30 seconds for the service to recover before retrying with a new message.

For this example, you need one config with these circuit breaker parameters:

[source,xml,linenums]
----

<anypoint-mq:config name="Anypoint_MQ_Config">
    <anypoint-mq:connection url="${providerUrl}"
    clientId="${clientId}"
    clientSecret="${clientSecret}"/>
</anypoint-mq:config>

<flow name="subscribe">
   <anypoint-mq:subscriber config-ref="Anypoint_MQ_Config"
      destination="${subscribedQueue}">
        <anypoint-mq:circuit-breaker
          onErrorTypes="HTTP:TIMEOUT"   <!-- (1) -->
          errorsThreshold="5"           <!-- (2) -->
          tripTimeout="30"              <!-- (3) -->
          tripTimeoutUnit="SECONDS"/>
   </anypoint-mq:subscriber>
    <http:request config-ref="RequesterConfig"
       path="/external" method="POST"/> <!-- (4) -->
</flow>

----
[%noheader,cols="8,92,frame="none"]
|===
| *(1)* | Configures the error types to trip the circuit. When an error occurs for an `errorsThreshold` amount of times, polling stops.
| *(2)* | Sets the threshold for how many consequent messages must occur to consider the circuit to be in a failure state.
| *(3)* | Specifies how long to wait before resuming new message polling after the circuit breaker trips because the `errorsThreshold` is reached.
| *(4)* | Defines the operation to throw the error expected by the `onErrorTypes` parameters.
|===

The circuit breaker ignores all errors that aren't listed in the `onErrorTypes` parameter. In this example, the circuit breaker ignores errors such as `HTTP:BAD_REQUEST`.


====  Share a Circuit from Different Queues

In many cases, there's a single common service between the processing of messages from different queues. This example configures the `circuitName` parameter to bind both subscribers to a single circuit:

[source,xml,linenums]
----

<anypoint-mq:config name="Anypoint_MQ_Config">
    <anypoint-mq:connection url="${providerUrl}"
       clientId="${clientId}"
       clientSecret="${clientSecret}"/>
</anypoint-mq:config>

<anypoint-mq:circuit-breaker
    name="InvoiceProcess"                    <!-- (1) -->
    onErrorTypes="FTP:RETRY_EXHAUSTED, HTTP:SERVICE_UNAVAILABLE" <!-- (2) -->
    errorsThreshold="10"
    tripTimeout="5"
    tripTimeoutUnit="MINUTES"/>

<flow name="subscribe">
    <anypoint-mq:subscriber destination="${reservationsQueue}"
       config-ref="Anypoint_MQ_Config"
        circuitBreaker="GlobalCircuit"/>     <!-- (3) -->
    <flow-ref name="invoiceProcess">
</flow>

<flow name="otherSubscribe">
    <anypoint-mq:subscriber
      destination="${paymentsQueue}"
        config-ref="Anypoint_MQ_Config"
        circuitBreaker="GlobalCircuit"/>    <!-- (3) -->
    <flow-ref name="invoiceProcess">
</flow>

<sub-flow name="invoiceProcess">
  <ftp:write path="${auditFolder}"          <!-- (4) -->
	   config-ref="ftp-config"/>
  <http:request config-ref="requestConfig"  <!-- (5) -->
	   path="/external"/>
</sub-flow>

----

[%noheader,cols="8,92,frame="none"]
|===
| *(1)* | Sets the `name` parameter to share a common circuit breaker on multiple queues.
| *(2)* | Identifies 2 errors that can affect the processing of messages from the subscriber and passes each as a CSV list.
| *(3)* | For both subscribers, references the global circuit breaker configuration.
| *(4)* | This component might throw an `FTP:RETRY_EXHAUSTED` error along with many others. Only the `FTP:RETRY_EXHAUSTED` error is taken into account by the circuit breaker.
| *(5)* | The HTTP connector might throw an `HTTP:SERVICE_UNAVAILABLE` preventing the message to be processed.
|===

For this scenario, both subscribers stop polling for messages as soon as the error count reaches the `errorsThreshold="10"` value, counting both `FTP:RETRY_EXHAUSTED` and `HTTP:SERVICE_UNAVAILABLE` errors. When the `tripTimeout` elapses, one of the subscribers polls for a message and uses it to test the circuit, enabling the polling for both subscribers if the processing of that message succeeds.

== See Also

* xref:anypoint-mq/3.x/anypoint-mq-consume.adoc[Anypoint MQ Consume Operation]
* xref:anypoint-mq/3.x/anypoint-mq-ack.adoc[Anypoint MQ ACK and NACK Operations]
