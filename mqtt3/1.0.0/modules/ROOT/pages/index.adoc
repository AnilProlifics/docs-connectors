= MQTT3 Connector 1.0 - Mule 4

Support Category: https://www.mulesoft.com/legal/versioning-back-support-policy#anypoint-connectors[Select]

Anypoint Connector for MQTT3 (MQTT3 Connector) is an MQTT v3.x compliant MuleSoft extension. The connector consumes and produces MQTT (Message Queuing Telemetry Transport) messages. MQTT3 Connector supports all MQTT v3.x functionalities including message retention, last will and testament messages, and persistent sessions.

For compatibility information and fixed issues, see the MQTT3 Connector Release Notes.

== Prerequisites

To use this connector, you must be familiar with:

* MQTT v3.x protocol
* Anypoint Connectors
* Mule runtime engine (Mule)
* Elements and global elements in a Mule flow
* Creating a Mule app using Anypoint Studio (Studio)

Before creating an app, you must have Anypoint Platform and Anypoint Studio.

== Common Use Cases for the Connector

These are some common use cases for MQTT3 Connector:

* Connect to MQTT brokers in hunt mode setup and publish messages.
* Connect to MQTT brokers in reliable messaging schema and publish messages.
* Connect to an MQTT broker and set a last will and testament (LWT) message.
* Connect to an MQTT broker with TLS and listen for messages.
* Listen for messages on a unique or multiple topics.
* Listen for messages on multiple topics using single-level or multi-level wildcards.
* Publish messages to a topic.
* Publish messages with retention.
* Publish messages to an MQTT topic and set different Quality of Service (QoS) levels.

== Configure the Connector

MQTT3 Connector comes out of the box with a set of default values for both publishing and consuming messages. The only requirement is that you must configure which connection (`<mqtt3:connection>`) to use and that you specify a value for the client ID (`clientID`), which will uniquely identify that connection.

In the following example, you configure a minimal connection to a broker. The `<mqtt3:connection>` and `clientID` configurations look like this:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
    <mqtt3:connection clientId="smart-bentley-123" url="tcp://127.0.0.1:1883" />
</mqtt3:config>
----

If you want to specify each URL field separately, set the `<mqtt3:form-connection>` for the connection:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Form_Config">
    <mqtt3:form-connection clientId="smart-bentley-123" username="usertest" password="testpass" protocol="TCP" host="127.0.0.1" port="1883"/>
</mqtt3:config>
----

=== Define Advanced Connection Options

MQTT3 Connector enables you to define multiple default parameters while consuming or publishing messages. This way, you can define a global default behavior for all the operations associated with the configurations.

In the following example, you configure the keep alive internal time units (`keepAliveInterval` and `keepAliveIntervalUnit`) to set the maximum period of time that the connection is kept alive without any messages being exchanged between the client and broker. You also configure the maximum number of in-flight (`maxInFlight`) messages allowed:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
  <mqtt3:connection clientId="smart-bentley-123" url="tcp://127.0.0.1:1883">
      <mqtt3:connection-options maxInFlight="60" keepAliveInterval="60" keepAliveIntervalUnit="SECONDS" />
  </mqtt3:connection>
</mqtt3:config>
----

You can also configure advanced connection options:

* `maxInFlight` +
The maximum amount of messages to unacknowledge at a given time.
* `cleanSession` +
If set to `true`, the session is cleaned each time the client disconnects from the broker.
* `enableFilePersistence` +
If set to `true`, creates a file-based persistent data store, used to store outbound and inbound messages while they are in flight, enabling delivery to the QoS specified.
* `keepAliveInterval` +
The amount of time that the connection between the client and broker is kept alive without any messages exchanged.
* `keepAliveIntervalUnit` +
The unit of time that corresponds to the `keepAliveInterval` parameter
* `connectionTimeout` +
The socket connection timeout value. This attribute works in tandem with `timeoutUnit`. In the case of multiple fail-over URLs provided, the timeout applies to each URL individually.
* `timeoutUnit` +
A time unit to qualify the `connectionTimeout` attribute.


== Set a Client ID

The client ID is mandatory because it identifies an MQTT connection to a broker. Define a meaningful name that uniquely identifies a client or device that connects to an MQTT broker and not a random string. Set the client ID (`clientId`) in the connection element (`<mqtt3:connection>`)  of the configuration.

== Specify a Connection Protocol

MQTT supports protocols, which can be used to connect to and exchange MQTT messages with the broker. Configure the protocol in the connection string of the connector configuration. The default is TCP:

* TCP
* SSL/TLS
* WS
* WSS
* LOCAL


== Configure Credentials For Authentication

Authentication credentials are optional, but you can provide a username and a password if it is required.

In the following example, you configure the authentication in the `<mqtt3:connection>` by providing a basic `username` and `password`:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
    <mqtt3:connection clientId="smart-bentley-123" username="usertest" password="passtest" url="tcp://127.0.0.1:1883"/>
</mqtt3:config>
----

You can also provide a client certificate to authenticate the connection by setting a TLS context.

[source,xml,linenums]
----
<mqtt3:config name="MQTT_TLS_Config">
    <mqtt3:connection clientId="smart-bentley-tls-123" username="usertest" password="passtest" url="ssl://localhost:8883" >
        <tls:context>
            <tls:trust-store path="tls/truststore.jks" password="racing" type="jks"/>
        </tls:context>
        <mqtt3:connection-options maxInFlight="60" cleanSession="true" />
    </mqtt3:connection>
</mqtt3:config>
----


== Provide a Failover Server List

There are certain deployment schemas that consist of multiple brokers working together in order to provide clients with several connection endpoints. When there is more than one available server that the client can connect to, there are two possible scenarios: either each MQTT server is operating separately or they might be working together and sharing a state (cluster mode), in which case, you might want to specify how the MQTT client will behave in the event of a reconnection.

When you provide a failover server list, the connector can iterate over it until it successfully establishes a connection with one of the provided endpoints.

In the following example, the `<mqtt3:fail-over-connection>` and `<mqtt3:fail-over-url` configurations look like this:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_FailOver_Config">
    <mqtt3:fail-over-connection clientId="smart-bentley-123" >
        <mqtt3:fail-over-servers >
            <mqtt3:fail-over-url protocol="TCP" host="127.9.0.2" port="1883"/>
            <mqtt3:fail-over-url protocol="TCP" host="127.0.0.3" port="1884"/>
            <mqtt3:fail-over-url protocol="TCP" host="127.0.0.1" port="1883"/>
        </mqtt3:fail-over-servers>
        <mqtt3:connection-options maxInFlight="60" cleanSession="true" connectionTimeout="60" />
        </mqtt3:fail-over-connection>
</mqtt3:config>
----

== Configure the Clean Session

Set the clean session (`cleanSession`) flag to `false` so the broker remembers the client the next time it connects. While the client is offline, all its subscriptions are saved, and Quality of Service (QoS) 1 and 2 messages that the client would want to receive are saved too, until the client reconnects.

Some brokers support the clustering of MQTT brokers in which the nodes share a state. In this case, setting the clean session flag to `false` can be useful if the node the connector is talking to happens to go offline. This enables the client to reconnect to a different node that is aware of the client's subscriptions so that any messages the connector might have missed while offline are delivered.

If clean session is set to `true` (default), then when the connector disconnects, for whatever reason, all its subscriptions will be dropped and it will have to resubscribe upon reconnection. All messages sent for it while offline are lost.

In the following example, the `cleanSession` configuration looks like this:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
  <mqtt3:connection clientId="smart-bentley-123" url="tcp://127.0.0.1:1883">
      <mqtt3:connection-options cleanSession="false"/>
    </mqtt3:connection>
</mqtt3:config>
----

== Enable File Persistence

Enabling file persistence by setting the `enableFilePersistence` flag to `true`, enables the MQTT client to persist its state
to a file that is used to store any outbound or inbound in-flight messages the client might have with QoS â‰¥ 1. In contrast,
if `enableFilePersistence` flag is set to `false`, the client state is only saved in memory and in the event of a crash
the client is not be able to recover its state.

In the following example, the `enableFilePersistence` configuration looks like this:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
  <mqtt3:connection clientId="smart-bentley-123">
       <mqtt3:connection-options cleanSession="false" enableFilePersistence="true"/>
    </mqtt3:connection>
</mqtt3:config>
----

== See Also

* xref:connectors::introduction/introduction-to-anypoint-connectors.adoc[Introduction to Anypoint Connectors]
* xref:connectors::introduction/intro-use-exchange.adoc[Use Exchange to Discover Connectors, Templates, and Examples]
* https://help.mulesoft.com[MuleSoft Help Center]
