= Listen for New Messages with MQTT3 Connector

The Anypoint Connector for MQTT3 (MQTT3 Connector) *On New Message* (`<mqtt3:listener>`) source enables you to listen for new incoming messages using one or more topic filters (`topicFilter`). Each topic filter has a specific quality of service (`qos`) configured.

In the Configuration XML editor, the `<mqtt3:listener>` and `<mqtt3:topic>` configurations look like this:

[source,xml,linenums]
----
    <flow name="listenerAuthorQuotes">
        <mqtt3:listener config-ref="MQTT_Config">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="quotes/terryPratchett" qos="EXACTLY_ONCE"/>
                <mqtt3:topic topicFilter="quotes/neilGaiman" qos="AT_LEAST_ONCE" />
                <mqtt3:topic topicFilter="quotes/ianMcEwan" qos="AT_MOST_ONCE" />
            </mqtt3:topics>
        </mqtt3:listener>
    </flow>
----

== Configure Single-Level Wildcards in Topic Filters

Configure single-level wildcards to listen to multiple topics. Single-level wildcards (`+`) enable the subscriber to receive messages published to all topics matching a specific structure.

In the following example, you configure the `topicFilter` parameter with the structure `quotes/+/authors`:

[source,xml,linenums]
----
    <flow name="quotes">
        <mqtt3:listener config-ref="${config}">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="quotes/+/authors"/>
            </mqtt3:topics>
        </mqtt3:listener>

        <logger level="DEBUG" message="A quote has been published to #[attributes.topic]: #[payload]"/>
    </flow>
----

Messages published to the following topics trigger the listener:

* `quotes/british/authors`
* `quotes/american/authors`

However, messages published to the following topics do not trigger the listener:

* `names/british/authors`
* `quotes/american/writers`


== Configure Multi-Level Wildcards in Topic Filters

Configure multi-level wildcards to enable the listener to subscribe to all topics that share the same root (everything that comes before the hash `#` symbol).

In the following example, you configure the `topicFilter` parameter with the structure `quotes/england/#`:

[source,xml,linenums]
----
    <flow name="listenerArgentinaTemperature">
        <mqtt3:listener config-ref="${config}">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="quotes/england/#"/>
            </mqtt3:topics>
        </mqtt3:listener>

        <logger level="DEBUG" message="A quote has been published to #[attributes.topic]: #[payload]"/>
    </flow>
----

Messages published to the following topics trigger the listener:

* `quotes/england/authors/terryPratchett`
* `quotes/england/authors/neilGaiman`
* `quotes/england/actors`

However, messages published to the following topics do not trigger the listener:

* `quotes/american/actors`
* `phrases/england/authors/neilGaiman`

== Sharing Configuration

Listeners that share a configuration element will also share a connection and client id. This is important to keep in mind
especially in the cases where one of the listeners is stopped but the other isn't.

Suppose we have the following configuration element and listeners in our application:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
    <mqtt3:connection clientId="smart-bentley-123" url="tcp://127.0.0.1:1883" />
</mqtt3:config>
<flow name="listenerReaderA">
   <mqtt3:listener config-ref="MQTT_Config">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="shakespeare"/>
                <mqtt3:topic topicFilter="terryPratchett"/>
            </mqtt3:topics>
   </mqtt3:listener>
   <logger level="INFO"  message="Received message '#[payload]' with at topic #[attributes.topic] with qos #[attributes.qos]">
</flow>
<flow name="listenerReaderB">
    <mqtt3:listener config-ref="MQTT_Config">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="neilGaiman"/>
                <mqtt3:topic topicFilter="terryPratchett"/>
            </mqtt3:topics>
   </mqtt3:listener>
   <logger level="INFO"  message="Received message '#[payload]' with at topic #[attributes.topic] with qos #[attributes.qos]">
</flow>
----

As you can see, the listeners share the configuration, therefore they also share a connection and a client id, and will be indistinguishable from one another from the broker's perspective. You will also notice, that the listeners share a subscription to the topic 'terryPratchett'. The first thing to note, is that in this case, whichever listener subscribes first will be the one to set the subscription quality of service. Only one subscription with one quality of service level will exist for that topic. The second observation is that, if we were to stop the 'listenerReaderB' flow, the 'listenerReaderA' flow will still receive and process the messages for the 'terryPratchett' topic, and so, even if the configuration element has specified a cleanSession=false, the messages that were processed while 'listenerReaderB' was offline, will not be resent to this listener.

== See Also

* xref:mqtt3-connector-examples.adoc[MQTT3 Connector Examples]
* https://help.mulesoft.com[MuleSoft Help Center]
