= Listen for New Messages with MQTT 3 Connector

In these examples, you configure the Anypoint Connector for MQTT 3 (MQTT 3 Connector) *On New Message* (`<mqtt3:listener>`) source that enables you to listen for new incoming messages using one or more topic filters (`topicFilter`). Each topic filter has a specific quality of service (`qos`) configured.

In the Configuration XML editor, the `<mqtt3:listener>` and `<mqtt3:topic>` configurations look like this:

[source,xml,linenums]
----
    <flow name="listenerAuthorQuotes">
        <mqtt3:listener config-ref="MQTT_Config">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="quotes/terryPratchett" qos="EXACTLY_ONCE"/>
                <mqtt3:topic topicFilter="quotes/neilGaiman" qos="AT_LEAST_ONCE" />
                <mqtt3:topic topicFilter="quotes/ianMcEwan" qos="AT_MOST_ONCE" />
            </mqtt3:topics>
        </mqtt3:listener>
    </flow>
----

== Configure Single-Level Wildcards in Topic Filters

Configure single-level wildcards to listen to multiple topics. Single-level wildcards (`+`) enable the subscriber to receive messages published to all topics that matches a specific structure.

In the following example, you configure the `topicFilter` parameter with the structure `quotes/+/authors`:

[source,xml,linenums]
----
    <flow name="quotes">
        <mqtt3:listener config-ref="${config}">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="quotes/+/authors"/>
            </mqtt3:topics>
        </mqtt3:listener>

        <logger level="DEBUG" message="A quote has been published to #[attributes.topic]: #[payload]"/>
    </flow>
----

Messages published to the following topics trigger the listener:

* `quotes/british/authors`
* `quotes/american/authors`

However, messages published to the following topics do not trigger the listener:

* `names/british/authors`
* `quotes/american/writers`


== Configure Multi-Level Wildcards in Topic Filters

Configure multi-level wildcards to enable the listener to subscribe to all topics that share the same root (everything that comes before the hash `#` symbol).

In the following example, you configure the `topicFilter` parameter with the structure `quotes/england/#`:

[source,xml,linenums]
----
    <flow name="listenerArgentinaTemperature">
        <mqtt3:listener config-ref="${config}">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="quotes/england/#"/>
            </mqtt3:topics>
        </mqtt3:listener>

        <logger level="DEBUG" message="A quote has been published to #[attributes.topic]: #[payload]"/>
    </flow>
----

Messages published to the following topics trigger the listener:

* `quotes/england/authors/terryPratchett`
* `quotes/england/authors/neilGaiman`
* `quotes/england/actors`

However, messages published to the following topics do not trigger the listener:

* `quotes/american/actors`
* `phrases/england/authors/neilGaiman`

== Listeners Sharing a Configuration

Listeners that share a configuration element also share a connection and client ID. This is important to remember, especially in the cases where one of the listeners is stopped but the other isn't.

In the following example, the listeners of the flows `listenerReaderA` and `listenerReaderB` share the same connection `MQTT_Config` configuration and client ID. From the broker's perspective both listeners are indistinguishable:

[source,xml,linenums]
----
<mqtt3:config name="MQTT_Config">
    <mqtt3:connection url="tcp://127.0.0.1:1883" >
        <mqtt3:client-id-generator>
            <mqtt3:client-id-random-suffix-generator clientId="smart-bentley-123" />
        </mqtt3:client-id-generator>
    </mqtt3:connection>
</mqtt3:config>

<flow name="listenerReaderA">
   <mqtt3:listener config-ref="MQTT_Config">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="shakespeare"/>
                <mqtt3:topic topicFilter="terryPratchett"/>
            </mqtt3:topics>
   </mqtt3:listener>
   <logger level="INFO"  message="Received message '#[payload]' with at topic #[attributes.topic] with qos #[attributes.qos]">
</flow>
<flow name="listenerReaderB">
    <mqtt3:listener config-ref="MQTT_Config">
            <mqtt3:topics>
                <mqtt3:topic topicFilter="neilGaiman"/>
                <mqtt3:topic topicFilter="terryPratchett"/>
            </mqtt3:topics>
   </mqtt3:listener>
   <logger level="INFO"  message="Received message '#[payload]' with at topic #[attributes.topic] with qos #[attributes.qos]">
</flow>
----

As you can see from the previous XML example, the listeners also share a subscription to the topic `terryPratchett`. Whichever listener subscribes first to the topic can set the subscription quality of service (QoS). Only one subscription with one quality of service level can exist for that topic.

If the `listenerReaderB` flow stops, the `listenerReaderA` flow still receives and processes the messages for the `terryPratchett` topic. Even if the configuration element specifies `cleanSession=false`, the messages processed while `listenerReaderB` was offline, are not resent to `listenerReaderB`


== See Also

* xref:mqtt3-connector-examples.adoc[MQTT3 Connector Examples]
* https://help.mulesoft.com[MuleSoft Help Center]
