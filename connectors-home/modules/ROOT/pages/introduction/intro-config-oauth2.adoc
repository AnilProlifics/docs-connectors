= Configuring OAuth 2.0 for Connectors

Many services enable you to use an OAuth 2.0 authentication scheme for increased security when interacting with their APIs. Many connectors support configuring a standard OAuth 2.0 setup.

== Prerequisites

To configure OAuth 2.0 for a connector, you must have access to the following:

* OAuth provider (Okta, Azure AD, Google, PingFederate, and so on)
* Anypoint Studio
* Any connector with OAuth 2.0 support

== How to Configure OAuth 2.0 For a Connector

Anypoint Connectors use the Authorization Code grant flow for their OAuth 2.0 dance. //refer to config-param?? The following steps show how to configure OAuth 2.0 for a connector:

. Navigate to the path specified in the *Authorize path* parameter to begin the OAuth dance. For example, if you are running the connector on `localhost` and your path is set to `/authorize` with port `8080`, navigate to `http://localhost:8080/authorize`.
. Provide values for *Authorization URL*, *Scopes*, *Resource owner ID*, and *Callback path*. The following conditions must be true for the OAuth provider to accept the authorization request:
+
* The *Authorization URL* must be reachable from the user's browser.
* The provided scopes for *Scopes* are supported.
* The *Resource owner ID* (if provided) must be registered with the OAuth provider.
* The full *Callback path* must be registered with the OAuth provider.
. Enter your username, password, and other credentials that the OAuth provider accepts, such as 2FA requests. If the authentication is successful, the OAuth provider might ask permission for the application to access your account. This typically occurs the first time you authenticate.
. Once the OAuth provider authenticates the user and authorizes access to the connector, the user's web browser is redirected to the callback URL that is registered with the OAuth provider, for example, `http://localhost:8080/callback`. Ensure that the user running the flow has access to that server and endpoint, otherwise the authorization approval does not reach the connector. You can use `localhost` for testing locally, but you cannot use `localhost` for production environment and cloud deployment, for example, if your connector application is running on `http://my.server.com`, you must specify the *External callback URL* parameter with the `http://my.server.com/callback` value. The `http://my.server.com/callback` URL must also be registered with the OAuth provider.
. Once the user's browser successfully reaches the callback URL, the connector obtains an authorization code that is automatically exchanged for an access token using the URL configured in the *Access token URL* parameter. This token is long-lived and is automatically refreshed by the connector indefinitely (if the OAuth provider allows).

The connector is now fully authorized and can use any service that accepts its new access token issued by the OAuth provider.

[[configuration-parameters]]
=== OAuth 2.0 Configuration Parameters

Here are the configuration parameters typically available for OAuth 2.0 for connectors:

*OAuth 2.0 Authorization Code:*

[%header,cols="20s,20a,35a,20a,5a"]
|===
| Name | Type | Description | Default Value | Required
| Consumer Key | String | OAuth consumer key, as registered with the service provider. | | X
| Consumer Secret | String | OAuth consumer secret, as registered with the service provider. | | X
| Authorization URL | String | URL of the service provider's authorization endpoint in which the user is redirected to provide their user credentials. This URL typically ends with `/authorize`. | | X
| Access Token Url | String | URL of the service provider's access token endpoint in which the application automatically exchanges an authorization code for an access token. | | X
| Scopes | String | Space-delimited list of OAuth scopes to request during the OAuth dance. This value defaults to the scopes in the annotation. | `offline_access` |
| Resource owner ID | String | ID of the owner's user or account authorizing the connector to access their resources. | |
|===

*OAuth 2.0 Callback Config:*

[%header,cols="20s,20a,35a,20a,5a"]
|===
| Name | Type | Description | Default Value | Required
| Callback path | String | Path on your server in which the user's browser redirects to when authorization is successful with the OAuth provider. The callback path is typically `/callback`. This configuration uses your *HTTP Listener* setup to build the callback path, for example, `http://0.0.0.0:{port}/callback`. | | X
| Authorize path | String | Path on your server in which the user begins the OAuth dance. The authorize path is typically `/authorize`. | | X
| External Callback Url | String | Full, publicly accessible URL on your server in which the user's browser is redirected to when authorization is successful with the OAuth provider. This field enables you to override the *Callback path* parameter, for example, `http://my.server.com/callback`. | |
|===

== Example: How to Configure OAuth 2.0 For Gmail Connector

The following example shows how to configure OAuth 2.0 for Gmail Connector.

=== Setting up the provider
For this example we will be using the GMail connector, so to get started we can get our Google OAuth setup for any account we hold using the Google Cloud Console.

NOTE: If you didn't do this before, you will have to create a new project and enable the "GMail API" in the "Enabled APIs & Services" menu section.

You will need to add a new client to Google OAuth 2.0, this will be your connector application. Navigate to `APIs & Services > Credentials > Create Credentials > OAuth Client ID`

Here you can create a new "Web Application", name it "OAuthDemoApp" and add the following URL to the "Authorized redirect URIs": "http://127.0.0.1:8080/callback"

Click "Create" and copy the new Client ID and Client Secret somewhere safe for now, we will need it later. Click "OK" and now we're all set on the Identity Provider side.

=== Setting up the connector
Add into your pom.xml
```
<dependency>
    <groupId>com.mulesoft.connectors</groupId>
    <artifactId>mule4-gmail-connector</artifactId>
    <version>1.0.5</version>
    <classifier>mule-plugin</classifier>
</dependency>
```

Now we can create a new Gmail Connector Connection. Here we are going to need our Client ID and Client Secret from the previous step. We are going to put in our Client ID and Client Secret as our "Consumer Key" and "Consumer Secret" respectively.

NOTE: The GMail connector already comes with the Authorization URL, Access Token URL and Scopes pre-filled, so you don't need to do anything here, but if you're setting up a different connector that uses a third party Identity Provider like Okta or Ping, you will need to use their respective Authorization and Access Token URLs here as well as any required scopes.

We can leave the Resource Owner ID field empty.

image::intro-config-oauth2-gmail-config.png[GMail Connector Configuration]

Now we can configure our Callback configuration. We will need a HTTP Listener configuration for that, so go ahead and create a new HTTP Listener config. Set the protocol as HTTP, Host to "localhost" and port as "8080".

image::intro-config-oauth2-gmail-http-lisenter.png[]
The XML for this Listener would look like this:
```
<http:listener-config name="HTTP_Listener_config" >
		<http:listener-connection host="localhost" port="8080" />
</http:listener-config>
```

We can select this listener in our GMail Connection Configuration. Then set the "Callback path" as "callback" and "Authorize path" as "authorize". We can leave the external callback url empty.

image::intro-config-oauth2-gmail-callback.png[]

The XML would look something like this:
```
<gmail:config name="Gmail_Connector_Config" >
    <gmail:oauth2c-connection >
        <gmail:oauth-authorization-code consumerKey="YOUR_CLIENT_ID" consumerSecret="YOUR_CLIENT_SECRET" />
        <gmail:oauth-callback-config listenerConfig="HTTP_Listener_config" callbackPath="callback" authorizePath="authorize"/>
    </gmail:oauth2c-connection>
</gmail:config>
```

Now run the application and we're done.

=== OAuth Dance
It is time to perform the OAuth dance and authorize our application to access our GMail account via the Connector.
First, we will navigate in a browser to our Authorize Path, in this example it would be "http://localhost:8080/authorize". If everything is configured correctly this step will take us to a Google Authentication screen where we select our user account and give permission to the app to access our account. Google will show us a long list of permissions that it requires you to approve. For example:

image::intro-config-oauth2-gmail-permissions.png[]

NOTE: These permissions are dependent on the "Scopes" parameter we configured in our GMail Connection Configuration. It's ok to accept the defaults in this case, but if you wanted to limit the access to application you would remove the unwanted scopes here. For example, you could remove the "https://www.googleapis.com/auth/gmail.send" scope to disallow the connector from sending new emails from your account. However, this would also render parts of the connector dysfunctional, like "Send Message" or "Send Draft" operations.

Once you click "Allow", you will be redirected to "http://127.0.0.1:8080/callback". This is the exact Redirect URI that we configured in the Identity Provider and that is open in the connector configuration. If everything worked well, you should now see the text "Successfully retrieved access token" in the browser, and you can close it now. The Connector is now fully authorized and ready to use the account.

You won't need to authorize again unless you restart Anypoint Studio or the Access Token expires. Tokens are automatically refreshed as long as the refresh token flow is enabled in your Identity Provider, Google supports this automatically and so your tokens should be refreshed indefinitely as needed.

NOTE: If you want your authorization to persist over restarts, you can configure an object store in the GMail Connection Configuration.

=== Testing
Now that we have a functional and authorized connector setup, we can try retrieving some of our emails. Try creating a simple flow with a HTTP Listener listening on the path "/messages" and drag the "List Messages" Operation into the flow. Here the only required field is the "User id" which is the users email address that you want to access (given the email is part of your setup, useful for corporate email servers with multiple users registered under one company account for example). You can specify as "me" to retrieve emails from your main account directly. We can also set the max results to a lower number if we desire.

The example flow could looks like this in XML:
```
<flow name="oauthFlow" >
    <http:listener config-ref="HTTP_Listener_config" path="/messages"/>
    <gmail:gmailusersmessageslist config-ref="Gmail_Connector_Config" userIdUriParam="me" maxResultsQueryParam="5"/>
</flow>
```

now restart the project and try navigating to "http://localhost:8080/messages", you should see a JSON formatted list of message IDs and Thread IDs. You could retrieve the details of these messages or threads using the "Get Message" or "Get Thread" operations.

=== Full Example
your-project.xml:
```
<?xml version="1.0" encoding="UTF-8"?>

<mule xmlns:gmail="http://www.mulesoft.org/schema/mule/gmail" xmlns:http="http://www.mulesoft.org/schema/mule/http"
	xmlns="http://www.mulesoft.org/schema/mule/core"
	xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/gmail http://www.mulesoft.org/schema/mule/gmail/current/mule-gmail.xsd">
	<http:listener-config name="HTTP_Listener_config" >
		<http:listener-connection host="localhost" port="8080" />
	</http:listener-config>
	<gmail:config name="Gmail_Connector_Config">
		<gmail:oauth2c-connection >
			<gmail:oauth-authorization-code consumerKey="300484156412-lnrscnoef6d4tbla0itv4b7pej0dpr3j.apps.googleusercontent.com" consumerSecret="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" scopes="https://mail.google.com/ https://www.googleapis.com/auth/gmail.addons.current.action.compose https://www.googleapis.com/auth/gmail.addons.current.message.action https://www.googleapis.com/auth/gmail.addons.current.message.readonly https://www.googleapis.com/auth/gmail.compose https://www.googleapis.com/auth/gmail.insert https://www.googleapis.com/auth/gmail.labels https://www.googleapis.com/auth/gmail.modify https://www.googleapis.com/auth/gmail.readonly"/>
			<gmail:oauth-callback-config listenerConfig="HTTP_Listener_config" callbackPath="callback" authorizePath="authorize"/>
		</gmail:oauth2c-connection>
	</gmail:config>

	<flow name="oauthFlow" >
		<http:listener config-ref="HTTP_Listener_config" path="/messages"/>
		<gmail:gmailusersmessageslist config-ref="Gmail_Connector_Config" userIdUriParam="me" maxResultsQueryParam="5"/>
	</flow>
</mule>
```

== See Also

* xref:connectors-home::intro-config-oauth2-cloudhub.adoc[Configuring OAuth on CloudHub].
* https://help.mulesoft.com[MuleSoft Help Center]
