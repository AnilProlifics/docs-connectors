= Define Object Stores Examples - Mule 4
:page-aliases: connectors::object-store/object-store-to-define-a-new-os.adoc

You can define an Object Store globally in the app so it can be referenced by name and shared between multiple components, or you can create an Object Store for one particular component.

All Object Store operations can reference a global Object Store. For example, for an audit flow that verifies whether certain users are currently authorized, you can reference the Object Store that you defined:

`<os:contains id="#[userId]" objectStore="tokensStore" />`

[[global_os]]
== Define a Global Object Store

Using a global Object Store is ideal for:

* Sharing state across components
+
Because the Object Store is referenced by name, more than one component can use it. Suppose you have a two instances of Salesforce Connector that are configured in slightly different ways. You can use both instances with the same tokens to avoid the need to reauthenticate.
* Sharing state across Cluster Nodes
+
Using Mule in cluster mode, to have information that is available to every node in the cluster. 
* Using information in your app's logic
+
Object Store Connector is not only capable of defining the Object Store, it can also manipulate it.

Global Object Stores are defined as a top-level element with a name other components can reference. The following example creates an Object Store for access tokens:

[source,xml,linenums]
----
<os:object-store name="tokensStore"
  entryTtl="1"
  entryTtlUnit="HOURS"
  maxEntries="100"
  persistent="true"
  expirationInterval="30"
  expirationIntervalUnit="MINUTES" />
----

IMPORTANT: The following information applies only to an in-memory object store. In xref:object-store::index.adoc[Object Store v2], unlimited keys are allowed.

This example defines an Object Store named `tokensStore` that has these features:

* Persistence (`persistent="true"`)
+
Values are stored in disk and can survive a system restart. Setting `persistent` to `false` results in a transient store that stores information only in memory.
* Expiration (`expirationInterval`)
+
An expiration thread runs every 30 minutes and discards the elements that exceed their time to live (TTL) or their `maxEntries` limit.
* TTL (`entryTtl`) of 1 hour
+ 
Because access tokens are highly sensitive, you might not want to retain them for more than an hour. Every entry that exceeds the value given in `entryTtl` is automatically deleted.
* Size limit (`maxEntries`)
+
Anything over the limit of 100 entries are discarded when the expiration thread runs.

This example is for informational purposes and doesn't provide a recommended configuration for an Object Store that stores access tokens.

The next example configures Salesforce Connector authentication through OAuth, then stores the token in the Object Store created in the previous example (`tokensStore`):

[source,xml,linenums]
----
<sfdc:config-with-oauth name="salesforce-oauth"
  consumerKey="${salesforce.consumerKey}"
  consumerSecret="${salesforce.consumerSecret}">
    <sfdc:oauth-callback-config domain="localhost" localPort="8082"
      remotePort="8082" path="callback" connector-ref="HTTP_HTTPS" />
    <sfdc:oauth-store-config objectStore="tokensStore" />
</sfdc:config-with-oauth>
----

[[private_os]]
== Define a Private Object Store

Use a private Object Store for:

* Cases when the shared state is a security risk.
* Cases when you don't want anyone to manipulate the Object Store from the connector level. For example, to avoid the risk that someone changes the configuration of a *Clear* operation so that it deletes all of your authorization data.

You can define a private Object Store that is not defined as a global element and does not have a referable name, for example:

[source,xml,linenums]
----
<idempotent-message-validator idExpression="#[payload]"
  valueExpression="#[payload]">
    <os:private-object-store
                entryTtl="20"
                entryTtlUnit="MILLISECONDS"
                maxEntries="20"
                persistent="false"
                expirationInterval="20"
                expirationIntervalUnit="MILLISECONDS"/>
</idempotent-message-validator>
----

The example provides the idempotent message validator with a custom store that  only it can access.
